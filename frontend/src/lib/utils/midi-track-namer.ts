/**
 * MIDI Track Namer Utility
 * Adds track name meta events to MIDI files generated by ScribbleTune
 */

import * as fs from 'fs';
import * as path from 'path';

/**
 * Interface for MIDI track name configuration
 */
export interface TrackNameConfig {
  trackName: string;
  filename: string;
}

/**
 * MIDI file structure constants
 */
const MIDI_CONSTANTS = {
  // MIDI file header
  HEADER_CHUNK_TYPE: 'MThd',
  TRACK_CHUNK_TYPE: 'MTrk',
  
  // Meta events
  META_EVENT: 0xFF,
  TRACK_NAME: 0x03,
  END_OF_TRACK: 0x2F,
  
  // Variable length quantity
  VLQ_END_MASK: 0x80,
  VLQ_VALUE_MASK: 0x7F
};

/**
 * Converts a string to a Uint8Array
 */
function stringToBytes(str: string): Uint8Array {
  return new Uint8Array(Array.from(str).map(char => char.charCodeAt(0)));
}

/**
 * Converts a number to a variable length quantity (VLQ) as used in MIDI files
 */
function numberToVLQ(value: number): Uint8Array {
  const bytes: number[] = [];
  let remaining = value;
  
  do {
    bytes.unshift(remaining & 0x7F);
    remaining >>>= 7;
  } while (remaining > 0);
  
  // Set the high bit on all bytes except the last
  for (let i = 0; i < bytes.length - 1; i++) {
    bytes[i] |= 0x80;
  }
  
  return new Uint8Array(bytes);
}

/**
 * Converts a number to a big-endian 32-bit integer
 */
function numberToBE32(value: number): Uint8Array {
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setUint32(0, value, false); // false = big endian
  return new Uint8Array(buffer);
}

/**
 * Converts a number to a big-endian 16-bit integer
 */
function numberToBE16(value: number): Uint8Array {
  const buffer = new ArrayBuffer(2);
  const view = new DataView(buffer);
  view.setUint16(0, value, false); // false = big endian
  return new Uint8Array(buffer);
}

/**
 * Adds a track name meta event to a MIDI file
 * This is a simplified approach that works for Type 0 MIDI files (single track)
 */
export function addTrackNameToMidiFile(filePath: string, trackName: string): void {
  try {
    // Read the existing MIDI file
    const midiData = fs.readFileSync(filePath);
    const midiArray = new Uint8Array(midiData);
    
    // Find the track chunk
    let trackStart = -1;
    for (let i = 0; i < midiArray.length - 4; i++) {
      if (String.fromCharCode(...Array.from(midiArray.slice(i, i + 4))) === MIDI_CONSTANTS.TRACK_CHUNK_TYPE) {
        trackStart = i;
        break;
      }
    }
    
    if (trackStart === -1) {
      throw new Error('Could not find track chunk in MIDI file');
    }
    
    // Get track length (4 bytes after 'MTrk')
    const trackLength = (midiArray[trackStart + 4] << 24) | 
                       (midiArray[trackStart + 5] << 16) | 
                       (midiArray[trackStart + 6] << 8) | 
                       midiArray[trackStart + 7];
    
    // Create track name meta event
    const trackNameBytes = stringToBytes(trackName);
    const trackNameEvent = new Uint8Array([
      ...numberToVLQ(0), // Delta time (0 for immediate)
      MIDI_CONSTANTS.META_EVENT, // Meta event
      MIDI_CONSTANTS.TRACK_NAME, // Track name
      ...numberToVLQ(trackNameBytes.length), // Length of track name
      ...trackNameBytes // Track name data
    ]);
    
    // Create new MIDI data with track name inserted at the beginning of the track
    const trackDataStart = trackStart + 8; // After 'MTrk' and length
    const beforeTrackName = midiArray.slice(0, trackDataStart);
    const afterTrackName = midiArray.slice(trackDataStart);
    const newTrackLength = trackLength + trackNameEvent.length;
    
    // Create new file data
    const newMidiData = new Uint8Array(
      beforeTrackName.length + 
      4 + // New track length
      trackNameEvent.length + 
      afterTrackName.length
    );
    
    let offset = 0;
    
    // Copy header and track header
    newMidiData.set(beforeTrackName, offset);
    offset += beforeTrackName.length;
    
    // Update track length
    newMidiData.set(numberToBE32(newTrackLength), offset);
    offset += 4;
    
    // Add track name event
    newMidiData.set(trackNameEvent, offset);
    offset += trackNameEvent.length;
    
    // Copy rest of track data
    newMidiData.set(afterTrackName, offset);
    
    // Write the modified MIDI file
    fs.writeFileSync(filePath, newMidiData);
    
    console.log(`✅ Added track name "${trackName}" to ${path.basename(filePath)}`);
    
  } catch (error) {
    console.error(`❌ Error adding track name to ${filePath}:`, error);
    throw error;
  }
}

/**
 * Extracts track name from filename (removes extension and path)
 */
export function extractTrackNameFromFilename(filename: string): string {
  const basename = path.basename(filename);
  const nameWithoutExt = path.parse(basename).name;
  
  // Convert filename to a more readable track name
  // e.g., "01a_kick.mid" -> "Kick"
  const parts = nameWithoutExt.split('_');
  if (parts.length > 1) {
    // Remove prefix numbers and underscores, capitalize
    return parts[parts.length - 1]
      .split('')
      .map((char, index) => index === 0 ? char.toUpperCase() : char)
      .join('');
  }
  
  // Fallback: capitalize first letter
  return nameWithoutExt
    .split('')
    .map((char, index) => index === 0 ? char.toUpperCase() : char)
    .join('');
}

/**
 * Processes a MIDI file to add track name based on filename
 */
export function processMidiFileWithTrackName(filePath: string, customTrackName?: string): void {
  const trackName = customTrackName || extractTrackNameFromFilename(filePath);
  addTrackNameToMidiFile(filePath, trackName);
}

